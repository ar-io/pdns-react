import{cN as oe,cO as Tt,cP as xt,cQ as se,cR as Se,cS as Ie,cT as W,cU as Ae,cV as _e,cW as Oe,cX as ie}from"./index-d427e950.js";(function(){try{var t=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},e=new Error().stack;e&&(t._sentryDebugIds=t._sentryDebugIds||{},t._sentryDebugIds[e]="7dd82317-4a75-462e-b7d8-153c57e7fa5b",t._sentryDebugIdIdentifier="sentry-dbid-7dd82317-4a75-462e-b7d8-153c57e7fa5b")}catch{}})();function qe(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),f=Number(n>>o&s),i=Number(n&s),c=r?4:0,a=r?0:4;t.setUint32(e+c,f,r),t.setUint32(e+a,i,r)}const Ne=(t,e,n)=>t&e^~t&n,Ue=(t,e,n)=>t&e^t&n^e&n;class Te extends oe{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Tt(this.buffer)}update(e){xt(this);const{view:n,buffer:r,blockLen:o}=this;e=se(e);const s=e.length;for(let f=0;f<s;){const i=Math.min(o-this.pos,s-f);if(i===o){const c=Tt(e);for(;o<=s-f;f+=o)this.process(c,f);continue}r.set(e.subarray(f,f+i),this.pos),this.pos+=i,f+=i,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){xt(this),Se(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:f}=this;n[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>o-f&&(this.process(r,0),f=0);for(let u=f;u<o;u++)n[u]=0;qe(r,o-8,BigInt(this.length*8),s),this.process(r,0);const i=Tt(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=c/4,h=this.get();if(a>h.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)i.setUint32(4*u,h[u],s)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:f,pos:i}=this;return e.length=o,e.pos=i,e.finished=s,e.destroyed=f,o%n&&e.buffer.set(r),e}}const He=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),nt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),rt=new Uint32Array(64);class Re extends Te{constructor(){super(64,32,8,!1),this.A=nt[0]|0,this.B=nt[1]|0,this.C=nt[2]|0,this.D=nt[3]|0,this.E=nt[4]|0,this.F=nt[5]|0,this.G=nt[6]|0,this.H=nt[7]|0}get(){const{A:e,B:n,C:r,D:o,E:s,F:f,G:i,H:c}=this;return[e,n,r,o,s,f,i,c]}set(e,n,r,o,s,f,i,c){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=f|0,this.G=i|0,this.H=c|0}process(e,n){for(let u=0;u<16;u++,n+=4)rt[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const v=rt[u-15],E=rt[u-2],y=W(v,7)^W(v,18)^v>>>3,l=W(E,17)^W(E,19)^E>>>10;rt[u]=l+rt[u-7]+y+rt[u-16]|0}let{A:r,B:o,C:s,D:f,E:i,F:c,G:a,H:h}=this;for(let u=0;u<64;u++){const v=W(i,6)^W(i,11)^W(i,25),E=h+v+Ne(i,c,a)+He[u]+rt[u]|0,l=(W(r,2)^W(r,13)^W(r,22))+Ue(r,o,s)|0;h=a,a=c,c=i,i=f+E|0,f=s,s=o,o=r,r=E+l|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,f=f+this.D|0,i=i+this.E|0,c=c+this.F|0,a=a+this.G|0,h=h+this.H|0,this.set(r,o,s,f,i,c,a,h)}roundClean(){rt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Et=Ie(()=>new Re);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ce=BigInt(0),At=BigInt(1),Le=BigInt(2);function lt(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function X(t){if(!lt(t))throw new Error("Uint8Array expected")}const Ce=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function bt(t){X(t);let e="";for(let n=0;n<t.length;n++)e+=Ce[t[n]];return e}function fe(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function Zt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}const Q={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Xt(t){if(t>=Q._0&&t<=Q._9)return t-Q._0;if(t>=Q._A&&t<=Q._F)return t-(Q._A-10);if(t>=Q._a&&t<=Q._f)return t-(Q._a-10)}function wt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let o=0,s=0;o<n;o++,s+=2){const f=Xt(t.charCodeAt(s)),i=Xt(t.charCodeAt(s+1));if(f===void 0||i===void 0){const c=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}r[o]=f*16+i}return r}function V(t){return Zt(bt(t))}function Pt(t){return X(t),Zt(bt(Uint8Array.from(t).reverse()))}function it(t,e){return wt(t.toString(16).padStart(e*2,"0"))}function zt(t,e){return it(t,e).reverse()}function $e(t){return wt(fe(t))}function $(t,e,n){let r;if(typeof e=="string")try{r=wt(e)}catch(s){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${s}`)}else if(lt(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function j(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];X(o),e+=o.length}const n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const s=t[r];n.set(s,o),o+=s.length}return n}function ke(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}function _t(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Ve(t){let e;for(e=0;t>ce;t>>=At,e+=1);return e}function Ze(t,e){return t>>BigInt(e)&At}function Pe(t,e,n){return t|(n?At:ce)<<BigInt(e)}const Dt=t=>(Le<<BigInt(t-1))-At,Ht=t=>new Uint8Array(t),Qt=t=>Uint8Array.from(t);function ae(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=Ht(t),o=Ht(t),s=0;const f=()=>{r.fill(1),o.fill(0),s=0},i=(...u)=>n(o,r,...u),c=(u=Ht())=>{o=i(Qt([0]),u),r=i(),u.length!==0&&(o=i(Qt([1]),u),r=i())},a=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const v=[];for(;u<e;){r=i();const E=r.slice();v.push(E),u+=r.length}return j(...v)};return(u,v)=>{f(),c(u);let E;for(;!(E=v(a()));)c();return f(),E}}const ze={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||lt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function yt(t,e,n={}){const r=(o,s,f)=>{const i=ze[s];if(typeof i!="function")throw new Error(`Invalid validator "${s}", expected function`);const c=t[o];if(!(f&&c===void 0)&&!i(c,t))throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${s}`)};for(const[o,s]of Object.entries(e))r(o,s,!1);for(const[o,s]of Object.entries(n))r(o,s,!0);return t}const De=Object.freeze(Object.defineProperty({__proto__:null,abytes:X,bitGet:Ze,bitLen:Ve,bitMask:Dt,bitSet:Pe,bytesToHex:bt,bytesToNumberBE:V,bytesToNumberLE:Pt,concatBytes:j,createHmacDrbg:ae,ensureBytes:$,equalBytes:ke,hexToBytes:wt,hexToNumber:Zt,isBytes:lt,numberToBytesBE:it,numberToBytesLE:zt,numberToHexUnpadded:fe,numberToVarBytesBE:$e,utf8ToBytes:_t,validateObject:yt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const C=BigInt(0),H=BigInt(1),at=BigInt(2),je=BigInt(3),Ct=BigInt(4),Jt=BigInt(5),Ft=BigInt(8);BigInt(9);BigInt(16);function L(t,e){const n=t%e;return n>=C?n:e+n}function Ke(t,e,n){if(n<=C||e<C)throw new Error("Expected power/modulo > 0");if(n===H)return C;let r=H;for(;e>C;)e&H&&(r=r*t%n),t=t*t%n,e>>=H;return r}function K(t,e,n){let r=t;for(;e-- >C;)r*=r,r%=n;return r}function $t(t,e){if(t===C||e<=C)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=L(t,e),r=e,o=C,s=H;for(;n!==C;){const i=r/n,c=r%n,a=o-s*i;r=n,n=c,o=s,s=a}if(r!==H)throw new Error("invert: does not exist");return L(o,e)}function Me(t){const e=(t-H)/at;let n,r,o;for(n=t-H,r=0;n%at===C;n/=at,r++);for(o=at;o<t&&Ke(o,e,t)!==t-H;o++);if(r===1){const f=(t+H)/Ct;return function(c,a){const h=c.pow(a,f);if(!c.eql(c.sqr(h),a))throw new Error("Cannot find square root");return h}}const s=(n+H)/at;return function(i,c){if(i.pow(c,e)===i.neg(i.ONE))throw new Error("Cannot find square root");let a=r,h=i.pow(i.mul(i.ONE,o),n),u=i.pow(c,s),v=i.pow(c,n);for(;!i.eql(v,i.ONE);){if(i.eql(v,i.ZERO))return i.ZERO;let E=1;for(let l=i.sqr(v);E<a&&!i.eql(l,i.ONE);E++)l=i.sqr(l);const y=i.pow(h,H<<BigInt(a-E-1));h=i.sqr(y),u=i.mul(u,y),v=i.mul(v,h),a=E}return u}}function Ye(t){if(t%Ct===je){const e=(t+H)/Ct;return function(r,o){const s=r.pow(o,e);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%Ft===Jt){const e=(t-Jt)/Ft;return function(r,o){const s=r.mul(o,at),f=r.pow(s,e),i=r.mul(o,f),c=r.mul(r.mul(i,at),f),a=r.mul(i,r.sub(c,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return Me(t)}const Ge=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ue(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=Ge.reduce((r,o)=>(r[o]="function",r),e);return yt(t,n)}function We(t,e,n){if(n<C)throw new Error("Expected power > 0");if(n===C)return t.ONE;if(n===H)return e;let r=t.ONE,o=e;for(;n>C;)n&H&&(r=t.mul(r,o)),o=t.sqr(o),n>>=H;return r}function Xe(t,e){const n=new Array(e.length),r=e.reduce((s,f,i)=>t.is0(f)?s:(n[i]=s,t.mul(s,f)),t.ONE),o=t.inv(r);return e.reduceRight((s,f,i)=>t.is0(f)?s:(n[i]=t.mul(s,n[i]),t.mul(s,f)),o),n}function le(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Qe(t,e,n=!1,r={}){if(t<=C)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:s}=le(t,e);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=Ye(t),i=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:Dt(o),ZERO:C,ONE:H,create:c=>L(c,t),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return C<=c&&c<t},is0:c=>c===C,isOdd:c=>(c&H)===H,neg:c=>L(-c,t),eql:(c,a)=>c===a,sqr:c=>L(c*c,t),add:(c,a)=>L(c+a,t),sub:(c,a)=>L(c-a,t),mul:(c,a)=>L(c*a,t),pow:(c,a)=>We(i,c,a),div:(c,a)=>L(c*$t(a,t),t),sqrN:c=>c*c,addN:(c,a)=>c+a,subN:(c,a)=>c-a,mulN:(c,a)=>c*a,inv:c=>$t(c,t),sqrt:r.sqrt||(c=>f(i,c)),invertBatch:c=>Xe(i,c),cmov:(c,a,h)=>h?a:c,toBytes:c=>n?zt(c,s):it(c,s),fromBytes:c=>{if(c.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);return n?Pt(c):V(c)}});return Object.freeze(i)}function de(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function he(t){const e=de(t);return e+Math.ceil(e/2)}function Je(t,e,n=!1){const r=t.length,o=de(e),s=he(e);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const f=n?V(t):Pt(t),i=L(f,e-H)+H;return n?zt(i,o):it(i,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Fe=BigInt(0),Rt=BigInt(1);function tn(t,e){const n=(o,s)=>{const f=s.negate();return o?f:s},r=o=>{const s=Math.ceil(e/o)+1,f=2**(o-1);return{windows:s,windowSize:f}};return{constTimeNegate:n,unsafeLadder(o,s){let f=t.ZERO,i=o;for(;s>Fe;)s&Rt&&(f=f.add(i)),i=i.double(),s>>=Rt;return f},precomputeWindow(o,s){const{windows:f,windowSize:i}=r(s),c=[];let a=o,h=a;for(let u=0;u<f;u++){h=a,c.push(h);for(let v=1;v<i;v++)h=h.add(a),c.push(h);a=h.double()}return c},wNAF(o,s,f){const{windows:i,windowSize:c}=r(o);let a=t.ZERO,h=t.BASE;const u=BigInt(2**o-1),v=2**o,E=BigInt(o);for(let y=0;y<i;y++){const l=y*c;let g=Number(f&u);f>>=E,g>c&&(g-=v,f+=Rt);const d=l,w=l+Math.abs(g)-1,p=y%2!==0,S=g<0;g===0?h=h.add(n(p,s[d])):a=a.add(n(S,s[w]))}return{p:a,f:h}},wNAFCached(o,s,f,i){const c=o._WINDOW_SIZE||1;let a=s.get(o);return a||(a=this.precomputeWindow(o,c),c!==1&&s.set(o,i(a))),this.wNAF(c,a,f)}}}function ge(t){return ue(t.Fp),yt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...le(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function en(t){const e=ge(t);yt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:nn,hexToBytes:rn}=De,ut={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=ut;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:nn(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=ut,n=typeof t=="string"?rn(t):t;X(n);let r=n.length;if(r<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:o,l:s}=ut._parseInt(n.subarray(2)),{d:f,l:i}=ut._parseInt(s);if(i.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s:f}},hexFromSig(t){const e=a=>Number.parseInt(a[0],16)&8?"00"+a:a,n=a=>{const h=a.toString(16);return h.length&1?`0${h}`:h},r=e(n(t.s)),o=e(n(t.r)),s=r.length/2,f=o.length/2,i=n(s),c=n(f);return`30${n(f+s+4)}02${c}${o}02${i}${r}`}},G=BigInt(0),T=BigInt(1),ot=BigInt(2),Bt=BigInt(3),te=BigInt(4);function on(t){const e=en(t),{Fp:n}=e,r=e.toBytes||((y,l,g)=>{const d=l.toAffine();return j(Uint8Array.from([4]),n.toBytes(d.x),n.toBytes(d.y))}),o=e.fromBytes||(y=>{const l=y.subarray(1),g=n.fromBytes(l.subarray(0,n.BYTES)),d=n.fromBytes(l.subarray(n.BYTES,2*n.BYTES));return{x:g,y:d}});function s(y){const{a:l,b:g}=e,d=n.sqr(y),w=n.mul(d,y);return n.add(n.add(w,n.mul(y,l)),g)}if(!n.eql(n.sqr(e.Gy),s(e.Gx)))throw new Error("bad generator point: equation left != right");function f(y){return typeof y=="bigint"&&G<y&&y<e.n}function i(y){if(!f(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(y){const{allowedPrivateKeyLengths:l,nByteLength:g,wrapPrivateKey:d,n:w}=e;if(l&&typeof y!="bigint"){if(lt(y)&&(y=bt(y)),typeof y!="string"||!l.includes(y.length))throw new Error("Invalid key");y=y.padStart(g*2,"0")}let p;try{p=typeof y=="bigint"?y:V($("private key",y,g))}catch{throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof y}`)}return d&&(p=L(p,w)),i(p),p}const a=new Map;function h(y){if(!(y instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,g,d){if(this.px=l,this.py=g,this.pz=d,l==null||!n.isValid(l))throw new Error("x required");if(g==null||!n.isValid(g))throw new Error("y required");if(d==null||!n.isValid(d))throw new Error("z required")}static fromAffine(l){const{x:g,y:d}=l||{};if(!l||!n.isValid(g)||!n.isValid(d))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");const w=p=>n.eql(p,n.ZERO);return w(g)&&w(d)?u.ZERO:new u(g,d,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const g=n.invertBatch(l.map(d=>d.pz));return l.map((d,w)=>d.toAffine(g[w])).map(u.fromAffine)}static fromHex(l){const g=u.fromAffine(o($("pointHex",l)));return g.assertValidity(),g}static fromPrivateKey(l){return u.BASE.multiply(c(l))}_setWindowSize(l){this._WINDOW_SIZE=l,a.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:l,y:g}=this.toAffine();if(!n.isValid(l)||!n.isValid(g))throw new Error("bad point: x or y not FE");const d=n.sqr(g),w=s(l);if(!n.eql(d,w))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:l}=this.toAffine();if(n.isOdd)return!n.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){h(l);const{px:g,py:d,pz:w}=this,{px:p,py:S,pz:A}=l,x=n.eql(n.mul(g,A),n.mul(p,w)),B=n.eql(n.mul(d,A),n.mul(S,w));return x&&B}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:l,b:g}=e,d=n.mul(g,Bt),{px:w,py:p,pz:S}=this;let A=n.ZERO,x=n.ZERO,B=n.ZERO,I=n.mul(w,w),k=n.mul(p,p),U=n.mul(S,S),O=n.mul(w,p);return O=n.add(O,O),B=n.mul(w,S),B=n.add(B,B),A=n.mul(l,B),x=n.mul(d,U),x=n.add(A,x),A=n.sub(k,x),x=n.add(k,x),x=n.mul(A,x),A=n.mul(O,A),B=n.mul(d,B),U=n.mul(l,U),O=n.sub(I,U),O=n.mul(l,O),O=n.add(O,B),B=n.add(I,I),I=n.add(B,I),I=n.add(I,U),I=n.mul(I,O),x=n.add(x,I),U=n.mul(p,S),U=n.add(U,U),I=n.mul(U,O),A=n.sub(A,I),B=n.mul(U,k),B=n.add(B,B),B=n.add(B,B),new u(A,x,B)}add(l){h(l);const{px:g,py:d,pz:w}=this,{px:p,py:S,pz:A}=l;let x=n.ZERO,B=n.ZERO,I=n.ZERO;const k=e.a,U=n.mul(e.b,Bt);let O=n.mul(g,p),z=n.mul(d,S),D=n.mul(w,A),J=n.add(g,d),b=n.add(p,S);J=n.mul(J,b),b=n.add(O,z),J=n.sub(J,b),b=n.add(g,w);let m=n.add(p,A);return b=n.mul(b,m),m=n.add(O,D),b=n.sub(b,m),m=n.add(d,w),x=n.add(S,A),m=n.mul(m,x),x=n.add(z,D),m=n.sub(m,x),I=n.mul(k,b),x=n.mul(U,D),I=n.add(x,I),x=n.sub(z,I),I=n.add(z,I),B=n.mul(x,I),z=n.add(O,O),z=n.add(z,O),D=n.mul(k,D),b=n.mul(U,b),z=n.add(z,D),D=n.sub(O,D),D=n.mul(k,D),b=n.add(b,D),O=n.mul(z,b),B=n.add(B,O),O=n.mul(m,b),x=n.mul(J,x),x=n.sub(x,O),O=n.mul(J,z),I=n.mul(m,I),I=n.add(I,O),new u(x,B,I)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return E.wNAFCached(this,a,l,g=>{const d=n.invertBatch(g.map(w=>w.pz));return g.map((w,p)=>w.toAffine(d[p])).map(u.fromAffine)})}multiplyUnsafe(l){const g=u.ZERO;if(l===G)return g;if(i(l),l===T)return this;const{endo:d}=e;if(!d)return E.unsafeLadder(this,l);let{k1neg:w,k1:p,k2neg:S,k2:A}=d.splitScalar(l),x=g,B=g,I=this;for(;p>G||A>G;)p&T&&(x=x.add(I)),A&T&&(B=B.add(I)),I=I.double(),p>>=T,A>>=T;return w&&(x=x.negate()),S&&(B=B.negate()),B=new u(n.mul(B.px,d.beta),B.py,B.pz),x.add(B)}multiply(l){i(l);let g=l,d,w;const{endo:p}=e;if(p){const{k1neg:S,k1:A,k2neg:x,k2:B}=p.splitScalar(g);let{p:I,f:k}=this.wNAF(A),{p:U,f:O}=this.wNAF(B);I=E.constTimeNegate(S,I),U=E.constTimeNegate(x,U),U=new u(n.mul(U.px,p.beta),U.py,U.pz),d=I.add(U),w=k.add(O)}else{const{p:S,f:A}=this.wNAF(g);d=S,w=A}return u.normalizeZ([d,w])[0]}multiplyAndAddUnsafe(l,g,d){const w=u.BASE,p=(A,x)=>x===G||x===T||!A.equals(w)?A.multiplyUnsafe(x):A.multiply(x),S=p(this,g).add(p(l,d));return S.is0()?void 0:S}toAffine(l){const{px:g,py:d,pz:w}=this,p=this.is0();l==null&&(l=p?n.ONE:n.inv(w));const S=n.mul(g,l),A=n.mul(d,l),x=n.mul(w,l);if(p)return{x:n.ZERO,y:n.ZERO};if(!n.eql(x,n.ONE))throw new Error("invZ was invalid");return{x:S,y:A}}isTorsionFree(){const{h:l,isTorsionFree:g}=e;if(l===T)return!0;if(g)return g(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:g}=e;return l===T?this:g?g(u,this):this.multiplyUnsafe(e.h)}toRawBytes(l=!0){return this.assertValidity(),r(u,this,l)}toHex(l=!0){return bt(this.toRawBytes(l))}}u.BASE=new u(e.Gx,e.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const v=e.nBitLength,E=tn(u,e.endo?Math.ceil(v/2):v);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:f}}function sn(t){const e=ge(t);return yt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function cn(t){const e=sn(t),{Fp:n,n:r}=e,o=n.BYTES+1,s=2*n.BYTES+1;function f(b){return G<b&&b<n.ORDER}function i(b){return L(b,r)}function c(b){return $t(b,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:h,weierstrassEquation:u,isWithinCurveOrder:v}=on({...e,toBytes(b,m,_){const N=m.toAffine(),q=n.toBytes(N.x),R=j;return _?R(Uint8Array.from([m.hasEvenY()?2:3]),q):R(Uint8Array.from([4]),q,n.toBytes(N.y))},fromBytes(b){const m=b.length,_=b[0],N=b.subarray(1);if(m===o&&(_===2||_===3)){const q=V(N);if(!f(q))throw new Error("Point is not on curve");const R=u(q);let Z;try{Z=n.sqrt(R)}catch(M){const tt=M instanceof Error?": "+M.message:"";throw new Error("Point is not on curve"+tt)}const P=(Z&T)===T;return(_&1)===1!==P&&(Z=n.neg(Z)),{x:q,y:Z}}else if(m===s&&_===4){const q=n.fromBytes(N.subarray(0,n.BYTES)),R=n.fromBytes(N.subarray(n.BYTES,2*n.BYTES));return{x:q,y:R}}else throw new Error(`Point of length ${m} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),E=b=>bt(it(b,e.nByteLength));function y(b){const m=r>>T;return b>m}function l(b){return y(b)?i(-b):b}const g=(b,m,_)=>V(b.slice(m,_));class d{constructor(m,_,N){this.r=m,this.s=_,this.recovery=N,this.assertValidity()}static fromCompact(m){const _=e.nByteLength;return m=$("compactSignature",m,_*2),new d(g(m,0,_),g(m,_,2*_))}static fromDER(m){const{r:_,s:N}=ut.toSig($("DER",m));return new d(_,N)}assertValidity(){if(!v(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!v(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(m){return new d(this.r,this.s,m)}recoverPublicKey(m){const{r:_,s:N,recovery:q}=this,R=B($("msgHash",m));if(q==null||![0,1,2,3].includes(q))throw new Error("recovery id invalid");const Z=q===2||q===3?_+e.n:_;if(Z>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const P=q&1?"03":"02",F=a.fromHex(P+E(Z)),M=c(Z),tt=i(-R*M),mt=i(N*M),et=a.BASE.multiplyAndAddUnsafe(F,tt,mt);if(!et)throw new Error("point at infinify");return et.assertValidity(),et}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return wt(this.toDERHex())}toDERHex(){return ut.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return wt(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}const w={isValidPrivateKey(b){try{return h(b),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const b=he(e.n);return Je(e.randomBytes(b),e.n)},precompute(b=8,m=a.BASE){return m._setWindowSize(b),m.multiply(BigInt(3)),m}};function p(b,m=!0){return a.fromPrivateKey(b).toRawBytes(m)}function S(b){const m=lt(b),_=typeof b=="string",N=(m||_)&&b.length;return m?N===o||N===s:_?N===2*o||N===2*s:b instanceof a}function A(b,m,_=!0){if(S(b))throw new Error("first arg must be private key");if(!S(m))throw new Error("second arg must be public key");return a.fromHex(m).multiply(h(b)).toRawBytes(_)}const x=e.bits2int||function(b){const m=V(b),_=b.length*8-e.nBitLength;return _>0?m>>BigInt(_):m},B=e.bits2int_modN||function(b){return i(x(b))},I=Dt(e.nBitLength);function k(b){if(typeof b!="bigint")throw new Error("bigint expected");if(!(G<=b&&b<I))throw new Error(`bigint expected < 2^${e.nBitLength}`);return it(b,e.nByteLength)}function U(b,m,_=O){if(["recovered","canonical"].some(ft=>ft in _))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:q}=e;let{lowS:R,prehash:Z,extraEntropy:P}=_;R==null&&(R=!0),b=$("msgHash",b),Z&&(b=$("prehashed msgHash",N(b)));const F=B(b),M=h(m),tt=[k(M),k(F)];if(P!=null&&P!==!1){const ft=P===!0?q(n.BYTES):P;tt.push($("extraEntropy",ft))}const mt=j(...tt),et=F;function Ut(ft){const dt=x(ft);if(!v(dt))return;const Yt=c(dt),ht=a.BASE.multiply(dt).toAffine(),Y=i(ht.x);if(Y===G)return;const gt=i(Yt*i(et+Y*M));if(gt===G)return;let Gt=(ht.x===Y?0:2)|Number(ht.y&T),Wt=gt;return R&&y(gt)&&(Wt=l(gt),Gt^=1),new d(Y,Wt,Gt)}return{seed:mt,k2sig:Ut}}const O={lowS:e.lowS,prehash:!1},z={lowS:e.lowS,prehash:!1};function D(b,m,_=O){const{seed:N,k2sig:q}=U(b,m,_),R=e;return ae(R.hash.outputLen,R.nByteLength,R.hmac)(N,q)}a.BASE._setWindowSize(8);function J(b,m,_,N=z){var ht;const q=b;if(m=$("msgHash",m),_=$("publicKey",_),"strict"in N)throw new Error("options.strict was renamed to lowS");const{lowS:R,prehash:Z}=N;let P,F;try{if(typeof q=="string"||lt(q))try{P=d.fromDER(q)}catch(Y){if(!(Y instanceof ut.Err))throw Y;P=d.fromCompact(q)}else if(typeof q=="object"&&typeof q.r=="bigint"&&typeof q.s=="bigint"){const{r:Y,s:gt}=q;P=new d(Y,gt)}else throw new Error("PARSE");F=a.fromHex(_)}catch(Y){if(Y.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(R&&P.hasHighS())return!1;Z&&(m=e.hash(m));const{r:M,s:tt}=P,mt=B(m),et=c(tt),Ut=i(mt*et),ft=i(M*et),dt=(ht=a.BASE.multiplyAndAddUnsafe(F,Ut,ft))==null?void 0:ht.toAffine();return dt?i(dt.x)===M:!1}return{CURVE:e,getPublicKey:p,getSharedSecret:A,sign:D,verify:J,ProjectivePoint:a,Signature:d,utils:w}}function fn(t,e){const n=t.ORDER;let r=G;for(let y=n-T;y%ot===G;y/=ot)r+=T;const o=r,s=ot<<o-T-T,f=s*ot,i=(n-T)/f,c=(i-T)/ot,a=f-T,h=s,u=t.pow(e,i),v=t.pow(e,(i+T)/ot);let E=(y,l)=>{let g=u,d=t.pow(l,a),w=t.sqr(d);w=t.mul(w,l);let p=t.mul(y,w);p=t.pow(p,c),p=t.mul(p,d),d=t.mul(p,l),w=t.mul(p,y);let S=t.mul(w,d);p=t.pow(S,h);let A=t.eql(p,t.ONE);d=t.mul(w,v),p=t.mul(S,g),w=t.cmov(d,w,A),S=t.cmov(p,S,A);for(let x=o;x>T;x--){let B=x-ot;B=ot<<B-T;let I=t.pow(S,B);const k=t.eql(I,t.ONE);d=t.mul(w,g),g=t.mul(g,g),I=t.mul(S,g),w=t.cmov(d,w,k),S=t.cmov(I,S,k)}return{isValid:A,value:w}};if(t.ORDER%te===Bt){const y=(t.ORDER-Bt)/te,l=t.sqrt(t.neg(e));E=(g,d)=>{let w=t.sqr(d);const p=t.mul(g,d);w=t.mul(w,p);let S=t.pow(w,y);S=t.mul(S,p);const A=t.mul(S,l),x=t.mul(t.sqr(S),d),B=t.eql(x,g);let I=t.cmov(A,S,B);return{isValid:B,value:I}}}return E}function an(t,e){if(ue(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const n=fn(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,f,i,c,a,h,u;o=t.sqr(r),o=t.mul(o,e.Z),s=t.sqr(o),s=t.add(s,o),f=t.add(s,t.ONE),f=t.mul(f,e.B),i=t.cmov(e.Z,t.neg(s),!t.eql(s,t.ZERO)),i=t.mul(i,e.A),s=t.sqr(f),a=t.sqr(i),c=t.mul(a,e.A),s=t.add(s,c),s=t.mul(s,f),a=t.mul(a,i),c=t.mul(a,e.B),s=t.add(s,c),h=t.mul(o,f);const{isValid:v,value:E}=n(s,a);u=t.mul(o,r),u=t.mul(u,E),h=t.cmov(h,f,v),u=t.cmov(u,E,v);const y=t.isOdd(r)===t.isOdd(u);return u=t.cmov(t.neg(u),u,y),h=t.div(h,i),{x:h,y:u}}}const un=V;function st(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=t&255,t>>>=8;return new Uint8Array(n)}function ln(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function jt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function dn(t,e,n,r){X(t),X(e),jt(n),e.length>255&&(e=r(j(_t("H2C-OVERSIZE-DST-"),e)));const{outputLen:o,blockLen:s}=r,f=Math.ceil(n/o);if(f>255)throw new Error("Invalid xmd length");const i=j(e,st(e.length,1)),c=st(0,s),a=st(n,2),h=new Array(f),u=r(j(c,t,a,st(0,1),i));h[0]=r(j(u,st(1,1),i));for(let E=1;E<=f;E++){const y=[ln(u,h[E-1]),st(E+1,1),i];h[E]=r(j(...y))}return j(...h).slice(0,n)}function hn(t,e,n,r,o){if(X(t),X(e),jt(n),e.length>255){const s=Math.ceil(2*r/8);e=o.create({dkLen:s}).update(_t("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:n}).update(t).update(st(n,2)).update(e).update(st(e.length,1)).digest()}function ee(t,e,n){yt(n,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:s,hash:f,expand:i,DST:c}=n;X(t),jt(e);const a=typeof c=="string"?_t(c):c,h=r.toString(2).length,u=Math.ceil((h+o)/8),v=e*s*u;let E;if(i==="xmd")E=dn(t,a,v,f);else if(i==="xof")E=hn(t,a,v,o,f);else if(i==="_internal_pass")E=t;else throw new Error('expand must be "xmd" or "xof"');const y=new Array(e);for(let l=0;l<e;l++){const g=new Array(s);for(let d=0;d<s;d++){const w=u*(d+l*s),p=E.subarray(w,w+u);g[d]=L(un(p),r)}y[l]=g}return y}function gn(t,e){const n=e.map(r=>Array.from(r).reverse());return(r,o)=>{const[s,f,i,c]=n.map(a=>a.reduce((h,u)=>t.add(t.mul(h,r),u)));return r=t.div(s,f),o=t.mul(o,t.div(i,c)),{x:r,y:o}}}function bn(t,e,n){if(typeof e!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const s=ee(r,2,{...n,DST:n.DST,...o}),f=t.fromAffine(e(s[0])),i=t.fromAffine(e(s[1])),c=f.add(i).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){const s=ee(r,1,{...n,DST:n.encodeDST,...o}),f=t.fromAffine(e(s[0])).clearCofactor();return f.assertValidity(),f}}}class be extends oe{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,Ae(e);const r=se(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?e.create().update(r).digest():r);for(let f=0;f<s.length;f++)s[f]^=54;this.iHash.update(s),this.oHash=e.create();for(let f=0;f<s.length;f++)s[f]^=106;this.oHash.update(s),s.fill(0)}update(e){return xt(this),this.iHash.update(e),this}digestInto(e){xt(this),_e(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:f,outputLen:i}=this;return e=e,e.finished=o,e.destroyed=s,e.blockLen=f,e.outputLen=i,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const we=(t,e,n)=>new be(t,e).update(n).digest();we.create=(t,e)=>new be(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function wn(t){return{hash:t,hmac:(e,...n)=>we(t,e,Oe(...n)),randomBytes:ie}}function yn(t,e){const n=r=>cn({...t,...wn(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ot=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),vt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ye=BigInt(1),St=BigInt(2),ne=(t,e)=>(t+e/St)/e;function me(t){const e=Ot,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),f=BigInt(23),i=BigInt(44),c=BigInt(88),a=t*t*t%e,h=a*a*t%e,u=K(h,n,e)*h%e,v=K(u,n,e)*h%e,E=K(v,St,e)*a%e,y=K(E,o,e)*E%e,l=K(y,s,e)*y%e,g=K(l,i,e)*l%e,d=K(g,c,e)*g%e,w=K(d,i,e)*l%e,p=K(w,n,e)*h%e,S=K(p,f,e)*y%e,A=K(S,r,e)*a%e,x=K(A,St,e);if(!ct.eql(ct.sqr(x),t))throw new Error("Cannot find square root");return x}const ct=Qe(Ot,void 0,void 0,{sqrt:me}),qt=yn({a:BigInt(0),b:BigInt(7),Fp:ct,n:vt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=vt,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-ye*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,f=BigInt("0x100000000000000000000000000000000"),i=ne(s*t,e),c=ne(-r*t,e);let a=L(t-i*n-c*o,e),h=L(-i*r-c*s,e);const u=a>f,v=h>f;if(u&&(a=e-a),v&&(h=e-h),a>f||h>f)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:a,k2neg:v,k2:h}}}},Et),Nt=BigInt(0),pe=t=>typeof t=="bigint"&&Nt<t&&t<Ot,mn=t=>typeof t=="bigint"&&Nt<t&&t<vt,re={};function It(t,...e){let n=re[t];if(n===void 0){const r=Et(Uint8Array.from(t,o=>o.charCodeAt(0)));n=j(r,r),re[t]=n}return Et(j(n,...e))}const Kt=t=>t.toRawBytes(!0).slice(1),kt=t=>it(t,32),Lt=t=>L(t,Ot),pt=t=>L(t,vt),Mt=qt.ProjectivePoint,pn=(t,e,n)=>Mt.BASE.multiplyAndAddUnsafe(t,e,n);function Vt(t){let e=qt.utils.normPrivateKeyToScalar(t),n=Mt.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:pt(-e),bytes:Kt(n)}}function xe(t){if(!pe(t))throw new Error("bad x: need 0 < x < p");const e=Lt(t*t),n=Lt(e*t+BigInt(7));let r=me(n);r%St!==Nt&&(r=Lt(-r));const o=new Mt(t,r,ye);return o.assertValidity(),o}function Ee(...t){return pt(V(It("BIP0340/challenge",...t)))}function xn(t){return Vt(t).bytes}function En(t,e,n=ie(32)){const r=$("message",t),{bytes:o,scalar:s}=Vt(e),f=$("auxRand",n,32),i=kt(s^V(It("BIP0340/aux",f))),c=It("BIP0340/nonce",i,o,r),a=pt(V(c));if(a===Nt)throw new Error("sign failed: k is zero");const{bytes:h,scalar:u}=Vt(a),v=Ee(h,o,r),E=new Uint8Array(64);if(E.set(h,0),E.set(kt(pt(u+v*s)),32),!Be(E,r,o))throw new Error("sign: Invalid signature produced");return E}function Be(t,e,n){const r=$("signature",t,64),o=$("message",e),s=$("publicKey",n,32);try{const f=xe(V(s)),i=V(r.subarray(0,32));if(!pe(i))return!1;const c=V(r.subarray(32,64));if(!mn(c))return!1;const a=Ee(kt(i),Kt(f),o),h=pn(f,c,pt(-a));return!(!h||!h.hasEvenY()||h.toAffine().x!==i)}catch{return!1}}const An=(()=>({getPublicKey:xn,sign:En,verify:Be,utils:{randomPrivateKey:qt.utils.randomPrivateKey,lift_x:xe,pointToBytes:Kt,numberToBytesBE:it,bytesToNumberBE:V,taggedHash:It,mod:L}}))(),Bn=(()=>gn(ct,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(e=>BigInt(e)))))(),vn=(()=>an(ct,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ct.create(BigInt("-11"))}))(),ve=(()=>bn(qt.ProjectivePoint,t=>{const{x:e,y:n}=vn(ct.create(t[0]));return Bn(e,n)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ct.ORDER,m:1,k:128,expand:"xmd",hash:Et}))(),_n=(()=>ve.hashToCurve)(),On=(()=>ve.encodeToCurve)();export{On as encodeToCurve,_n as hashToCurve,An as schnorr,qt as secp256k1};
//# sourceMappingURL=secp256k1-7a25fcaa.js.map
